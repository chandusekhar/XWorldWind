//
// Type_WMSAccessor2.cs.cs
//
// This file was generated by XMLSpy 2005 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Collections;
using System.Xml;
using Altova.Types;

namespace LayerSet
{
	public class Type_WMSAccessor2 : Altova.Xml.Node
	{
		#region Forward constructors
		public Type_WMSAccessor2() : base() {
            this.SetCollectionParents(); }
		public Type_WMSAccessor2(XmlDocument doc) : base(doc) {
            this.SetCollectionParents(); }
		public Type_WMSAccessor2(XmlNode node) : base(node) {
            this.SetCollectionParents(); }
		public Type_WMSAccessor2(Altova.Xml.Node node) : base(node) {
            this.SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{

			for (int i = 0; i < this.DomChildCount(NodeType.Element, "", "Username"); i++)
			{
				XmlNode DOMNode = this.GetDomChildAt(NodeType.Element, "", "Username", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			for (int i = 0; i < this.DomChildCount(NodeType.Element, "", "Password"); i++)
			{
				XmlNode DOMNode = this.GetDomChildAt(NodeType.Element, "", "Password", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			for (int i = 0; i < this.DomChildCount(NodeType.Element, "", "ServerGetMapUrl"); i++)
			{
				XmlNode DOMNode = this.GetDomChildAt(NodeType.Element, "", "ServerGetMapUrl", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			for (int i = 0; i < this.DomChildCount(NodeType.Element, "", "Version"); i++)
			{
				XmlNode DOMNode = this.GetDomChildAt(NodeType.Element, "", "Version", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			for (int i = 0; i < this.DomChildCount(NodeType.Element, "", "ImageFormat"); i++)
			{
				XmlNode DOMNode = this.GetDomChildAt(NodeType.Element, "", "ImageFormat", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			for (int i = 0; i < this.DomChildCount(NodeType.Element, "", "WMSLayerName"); i++)
			{
				XmlNode DOMNode = this.GetDomChildAt(NodeType.Element, "", "WMSLayerName", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			for (int i = 0; i < this.DomChildCount(NodeType.Element, "", "WMSLayerStyle"); i++)
			{
				XmlNode DOMNode = this.GetDomChildAt(NodeType.Element, "", "WMSLayerStyle", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			for (int i = 0; i < this.DomChildCount(NodeType.Element, "", "UseTransparency"); i++)
			{
				XmlNode DOMNode = this.GetDomChildAt(NodeType.Element, "", "UseTransparency", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			for (int i = 0; i < this.DomChildCount(NodeType.Element, "", "CacheExpirationTime"); i++)
			{
				XmlNode DOMNode = this.GetDomChildAt(NodeType.Element, "", "CacheExpirationTime", i);
				InternalAdjustPrefix(DOMNode, true);
				new Type_SimpleTimeSpan2(DOMNode).AdjustPrefix();
			}

			for (int i = 0; i < this.DomChildCount(NodeType.Element, "", "BoundingBoxOverlap"); i++)
			{
				XmlNode DOMNode = this.GetDomChildAt(NodeType.Element, "", "BoundingBoxOverlap", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			for (int i = 0; i < this.DomChildCount(NodeType.Element, "", "ServerLogoFilePath"); i++)
			{
				XmlNode DOMNode = this.GetDomChildAt(NodeType.Element, "", "ServerLogoFilePath", i);
				InternalAdjustPrefix(DOMNode, true);
			}
		}


		#region Username accessor methods
		public int GetUsernameMinCount()
		{
			return 0;
		}

		public int UsernameMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetUsernameMaxCount()
		{
			return 1;
		}

		public int UsernameMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetUsernameCount()
		{
			return this.DomChildCount(NodeType.Element, "", "Username");
		}

		public int UsernameCount
		{
			get
			{
				return this.DomChildCount(NodeType.Element, "", "Username");
			}
		}

		public bool HasUsername()
		{
			return this.HasDomChild(NodeType.Element, "", "Username");
		}

		public SchemaString GetUsernameAt(int index)
		{
			return new SchemaString(GetDomNodeValue(this.GetDomChildAt(NodeType.Element, "", "Username", index)));
		}

		public XmlNode GetStartingUsernameCursor()
		{
			return this.GetDomFirstChild( NodeType.Element, "", "Username" );
		}

		public XmlNode GetAdvancedUsernameCursor( XmlNode curNode )
		{
			return this.GetDomNextChild( NodeType.Element, "", "Username", curNode );
		}

		public SchemaString GetUsernameValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetUsername()
		{
			return this.GetUsernameAt(0);
		}

		public SchemaString Username
		{
			get
			{
				return this.GetUsernameAt(0);
			}
		}

		public void RemoveUsernameAt(int index)
		{
            this.RemoveDomChildAt(NodeType.Element, "", "Username", index);
		}

		public void RemoveUsername()
		{
			while (this.HasUsername()) this.RemoveUsernameAt(0);
		}

		public void AddUsername(SchemaString newValue)
		{
            this.AppendDomChild(NodeType.Element, "", "Username", newValue.ToString());
		}

		public void InsertUsernameAt(SchemaString newValue, int index)
		{
            this.InsertDomChildAt(NodeType.Element, "", "Username", index, newValue.ToString());
		}

		public void ReplaceUsernameAt(SchemaString newValue, int index)
		{
            this.ReplaceDomChildAt(NodeType.Element, "", "Username", index, newValue.ToString());
		}
		#endregion // Username accessor methods

		#region Username collection
        public UsernameCollection	MyUsernames = new UsernameCollection( );

        public class UsernameCollection: IEnumerable
        {
            Type_WMSAccessor2 parent;
            public Type_WMSAccessor2 Parent
			{
				set
				{
                    this.parent = value;
				}
			}
			public UsernameEnumerator GetEnumerator() 
			{
				return new UsernameEnumerator(this.parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return this.GetEnumerator();
			}
        }

        public class UsernameEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor2 parent;
			public UsernameEnumerator(Type_WMSAccessor2 par) 
			{
                this.parent = par;
                this.nIndex = -1;
			}
			public void Reset() 
			{
                this.nIndex = -1;
			}
			public bool MoveNext() 
			{
                this.nIndex++;
				return(this.nIndex < this.parent.UsernameCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(this.parent.GetUsernameAt(this.nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(this.Current);
				}
			}
    	}

        #endregion // Username collection

		#region Password accessor methods
		public int GetPasswordMinCount()
		{
			return 0;
		}

		public int PasswordMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetPasswordMaxCount()
		{
			return 1;
		}

		public int PasswordMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetPasswordCount()
		{
			return this.DomChildCount(NodeType.Element, "", "Password");
		}

		public int PasswordCount
		{
			get
			{
				return this.DomChildCount(NodeType.Element, "", "Password");
			}
		}

		public bool HasPassword()
		{
			return this.HasDomChild(NodeType.Element, "", "Password");
		}

		public SchemaString GetPasswordAt(int index)
		{
			return new SchemaString(GetDomNodeValue(this.GetDomChildAt(NodeType.Element, "", "Password", index)));
		}

		public XmlNode GetStartingPasswordCursor()
		{
			return this.GetDomFirstChild( NodeType.Element, "", "Password" );
		}

		public XmlNode GetAdvancedPasswordCursor( XmlNode curNode )
		{
			return this.GetDomNextChild( NodeType.Element, "", "Password", curNode );
		}

		public SchemaString GetPasswordValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetPassword()
		{
			return this.GetPasswordAt(0);
		}

		public SchemaString Password
		{
			get
			{
				return this.GetPasswordAt(0);
			}
		}

		public void RemovePasswordAt(int index)
		{
            this.RemoveDomChildAt(NodeType.Element, "", "Password", index);
		}

		public void RemovePassword()
		{
			while (this.HasPassword()) this.RemovePasswordAt(0);
		}

		public void AddPassword(SchemaString newValue)
		{
            this.AppendDomChild(NodeType.Element, "", "Password", newValue.ToString());
		}

		public void InsertPasswordAt(SchemaString newValue, int index)
		{
            this.InsertDomChildAt(NodeType.Element, "", "Password", index, newValue.ToString());
		}

		public void ReplacePasswordAt(SchemaString newValue, int index)
		{
            this.ReplaceDomChildAt(NodeType.Element, "", "Password", index, newValue.ToString());
		}
		#endregion // Password accessor methods

		#region Password collection
        public PasswordCollection	MyPasswords = new PasswordCollection( );

        public class PasswordCollection: IEnumerable
        {
            Type_WMSAccessor2 parent;
            public Type_WMSAccessor2 Parent
			{
				set
				{
                    this.parent = value;
				}
			}
			public PasswordEnumerator GetEnumerator() 
			{
				return new PasswordEnumerator(this.parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return this.GetEnumerator();
			}
        }

        public class PasswordEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor2 parent;
			public PasswordEnumerator(Type_WMSAccessor2 par) 
			{
                this.parent = par;
                this.nIndex = -1;
			}
			public void Reset() 
			{
                this.nIndex = -1;
			}
			public bool MoveNext() 
			{
                this.nIndex++;
				return(this.nIndex < this.parent.PasswordCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(this.parent.GetPasswordAt(this.nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(this.Current);
				}
			}
    	}

        #endregion // Password collection

		#region ServerGetMapUrl accessor methods
		public int GetServerGetMapUrlMinCount()
		{
			return 1;
		}

		public int ServerGetMapUrlMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetServerGetMapUrlMaxCount()
		{
			return 1;
		}

		public int ServerGetMapUrlMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetServerGetMapUrlCount()
		{
			return this.DomChildCount(NodeType.Element, "", "ServerGetMapUrl");
		}

		public int ServerGetMapUrlCount
		{
			get
			{
				return this.DomChildCount(NodeType.Element, "", "ServerGetMapUrl");
			}
		}

		public bool HasServerGetMapUrl()
		{
			return this.HasDomChild(NodeType.Element, "", "ServerGetMapUrl");
		}

		public SchemaString GetServerGetMapUrlAt(int index)
		{
			return new SchemaString(GetDomNodeValue(this.GetDomChildAt(NodeType.Element, "", "ServerGetMapUrl", index)));
		}

		public XmlNode GetStartingServerGetMapUrlCursor()
		{
			return this.GetDomFirstChild( NodeType.Element, "", "ServerGetMapUrl" );
		}

		public XmlNode GetAdvancedServerGetMapUrlCursor( XmlNode curNode )
		{
			return this.GetDomNextChild( NodeType.Element, "", "ServerGetMapUrl", curNode );
		}

		public SchemaString GetServerGetMapUrlValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetServerGetMapUrl()
		{
			return this.GetServerGetMapUrlAt(0);
		}

		public SchemaString ServerGetMapUrl
		{
			get
			{
				return this.GetServerGetMapUrlAt(0);
			}
		}

		public void RemoveServerGetMapUrlAt(int index)
		{
            this.RemoveDomChildAt(NodeType.Element, "", "ServerGetMapUrl", index);
		}

		public void RemoveServerGetMapUrl()
		{
			while (this.HasServerGetMapUrl()) this.RemoveServerGetMapUrlAt(0);
		}

		public void AddServerGetMapUrl(SchemaString newValue)
		{
            this.AppendDomChild(NodeType.Element, "", "ServerGetMapUrl", newValue.ToString());
		}

		public void InsertServerGetMapUrlAt(SchemaString newValue, int index)
		{
            this.InsertDomChildAt(NodeType.Element, "", "ServerGetMapUrl", index, newValue.ToString());
		}

		public void ReplaceServerGetMapUrlAt(SchemaString newValue, int index)
		{
            this.ReplaceDomChildAt(NodeType.Element, "", "ServerGetMapUrl", index, newValue.ToString());
		}
		#endregion // ServerGetMapUrl accessor methods

		#region ServerGetMapUrl collection
        public ServerGetMapUrlCollection	MyServerGetMapUrls = new ServerGetMapUrlCollection( );

        public class ServerGetMapUrlCollection: IEnumerable
        {
            Type_WMSAccessor2 parent;
            public Type_WMSAccessor2 Parent
			{
				set
				{
                    this.parent = value;
				}
			}
			public ServerGetMapUrlEnumerator GetEnumerator() 
			{
				return new ServerGetMapUrlEnumerator(this.parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return this.GetEnumerator();
			}
        }

        public class ServerGetMapUrlEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor2 parent;
			public ServerGetMapUrlEnumerator(Type_WMSAccessor2 par) 
			{
                this.parent = par;
                this.nIndex = -1;
			}
			public void Reset() 
			{
                this.nIndex = -1;
			}
			public bool MoveNext() 
			{
                this.nIndex++;
				return(this.nIndex < this.parent.ServerGetMapUrlCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(this.parent.GetServerGetMapUrlAt(this.nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(this.Current);
				}
			}
    	}

        #endregion // ServerGetMapUrl collection

		#region Version accessor methods
		public int GetVersionMinCount()
		{
			return 1;
		}

		public int VersionMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetVersionMaxCount()
		{
			return 1;
		}

		public int VersionMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetVersionCount()
		{
			return this.DomChildCount(NodeType.Element, "", "Version");
		}

		public int VersionCount
		{
			get
			{
				return this.DomChildCount(NodeType.Element, "", "Version");
			}
		}

		public bool HasVersion()
		{
			return this.HasDomChild(NodeType.Element, "", "Version");
		}

		public SchemaString GetVersionAt(int index)
		{
			return new SchemaString(GetDomNodeValue(this.GetDomChildAt(NodeType.Element, "", "Version", index)));
		}

		public XmlNode GetStartingVersionCursor()
		{
			return this.GetDomFirstChild( NodeType.Element, "", "Version" );
		}

		public XmlNode GetAdvancedVersionCursor( XmlNode curNode )
		{
			return this.GetDomNextChild( NodeType.Element, "", "Version", curNode );
		}

		public SchemaString GetVersionValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetVersion()
		{
			return this.GetVersionAt(0);
		}

		public SchemaString Version
		{
			get
			{
				return this.GetVersionAt(0);
			}
		}

		public void RemoveVersionAt(int index)
		{
            this.RemoveDomChildAt(NodeType.Element, "", "Version", index);
		}

		public void RemoveVersion()
		{
			while (this.HasVersion()) this.RemoveVersionAt(0);
		}

		public void AddVersion(SchemaString newValue)
		{
            this.AppendDomChild(NodeType.Element, "", "Version", newValue.ToString());
		}

		public void InsertVersionAt(SchemaString newValue, int index)
		{
            this.InsertDomChildAt(NodeType.Element, "", "Version", index, newValue.ToString());
		}

		public void ReplaceVersionAt(SchemaString newValue, int index)
		{
            this.ReplaceDomChildAt(NodeType.Element, "", "Version", index, newValue.ToString());
		}
		#endregion // Version accessor methods

		#region Version collection
        public VersionCollection	MyVersions = new VersionCollection( );

        public class VersionCollection: IEnumerable
        {
            Type_WMSAccessor2 parent;
            public Type_WMSAccessor2 Parent
			{
				set
				{
                    this.parent = value;
				}
			}
			public VersionEnumerator GetEnumerator() 
			{
				return new VersionEnumerator(this.parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return this.GetEnumerator();
			}
        }

        public class VersionEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor2 parent;
			public VersionEnumerator(Type_WMSAccessor2 par) 
			{
                this.parent = par;
                this.nIndex = -1;
			}
			public void Reset() 
			{
                this.nIndex = -1;
			}
			public bool MoveNext() 
			{
                this.nIndex++;
				return(this.nIndex < this.parent.VersionCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(this.parent.GetVersionAt(this.nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(this.Current);
				}
			}
    	}

        #endregion // Version collection

		#region ImageFormat accessor methods
		public int GetImageFormatMinCount()
		{
			return 1;
		}

		public int ImageFormatMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetImageFormatMaxCount()
		{
			return 1;
		}

		public int ImageFormatMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetImageFormatCount()
		{
			return this.DomChildCount(NodeType.Element, "", "ImageFormat");
		}

		public int ImageFormatCount
		{
			get
			{
				return this.DomChildCount(NodeType.Element, "", "ImageFormat");
			}
		}

		public bool HasImageFormat()
		{
			return this.HasDomChild(NodeType.Element, "", "ImageFormat");
		}

		public SchemaString GetImageFormatAt(int index)
		{
			return new SchemaString(GetDomNodeValue(this.GetDomChildAt(NodeType.Element, "", "ImageFormat", index)));
		}

		public XmlNode GetStartingImageFormatCursor()
		{
			return this.GetDomFirstChild( NodeType.Element, "", "ImageFormat" );
		}

		public XmlNode GetAdvancedImageFormatCursor( XmlNode curNode )
		{
			return this.GetDomNextChild( NodeType.Element, "", "ImageFormat", curNode );
		}

		public SchemaString GetImageFormatValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetImageFormat()
		{
			return this.GetImageFormatAt(0);
		}

		public SchemaString ImageFormat
		{
			get
			{
				return this.GetImageFormatAt(0);
			}
		}

		public void RemoveImageFormatAt(int index)
		{
            this.RemoveDomChildAt(NodeType.Element, "", "ImageFormat", index);
		}

		public void RemoveImageFormat()
		{
			while (this.HasImageFormat()) this.RemoveImageFormatAt(0);
		}

		public void AddImageFormat(SchemaString newValue)
		{
            this.AppendDomChild(NodeType.Element, "", "ImageFormat", newValue.ToString());
		}

		public void InsertImageFormatAt(SchemaString newValue, int index)
		{
            this.InsertDomChildAt(NodeType.Element, "", "ImageFormat", index, newValue.ToString());
		}

		public void ReplaceImageFormatAt(SchemaString newValue, int index)
		{
            this.ReplaceDomChildAt(NodeType.Element, "", "ImageFormat", index, newValue.ToString());
		}
		#endregion // ImageFormat accessor methods

		#region ImageFormat collection
        public ImageFormatCollection	MyImageFormats = new ImageFormatCollection( );

        public class ImageFormatCollection: IEnumerable
        {
            Type_WMSAccessor2 parent;
            public Type_WMSAccessor2 Parent
			{
				set
				{
                    this.parent = value;
				}
			}
			public ImageFormatEnumerator GetEnumerator() 
			{
				return new ImageFormatEnumerator(this.parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return this.GetEnumerator();
			}
        }

        public class ImageFormatEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor2 parent;
			public ImageFormatEnumerator(Type_WMSAccessor2 par) 
			{
                this.parent = par;
                this.nIndex = -1;
			}
			public void Reset() 
			{
                this.nIndex = -1;
			}
			public bool MoveNext() 
			{
                this.nIndex++;
				return(this.nIndex < this.parent.ImageFormatCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(this.parent.GetImageFormatAt(this.nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(this.Current);
				}
			}
    	}

        #endregion // ImageFormat collection

		#region WMSLayerName accessor methods
		public int GetWMSLayerNameMinCount()
		{
			return 1;
		}

		public int WMSLayerNameMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetWMSLayerNameMaxCount()
		{
			return 1;
		}

		public int WMSLayerNameMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetWMSLayerNameCount()
		{
			return this.DomChildCount(NodeType.Element, "", "WMSLayerName");
		}

		public int WMSLayerNameCount
		{
			get
			{
				return this.DomChildCount(NodeType.Element, "", "WMSLayerName");
			}
		}

		public bool HasWMSLayerName()
		{
			return this.HasDomChild(NodeType.Element, "", "WMSLayerName");
		}

		public SchemaString GetWMSLayerNameAt(int index)
		{
			return new SchemaString(GetDomNodeValue(this.GetDomChildAt(NodeType.Element, "", "WMSLayerName", index)));
		}

		public XmlNode GetStartingWMSLayerNameCursor()
		{
			return this.GetDomFirstChild( NodeType.Element, "", "WMSLayerName" );
		}

		public XmlNode GetAdvancedWMSLayerNameCursor( XmlNode curNode )
		{
			return this.GetDomNextChild( NodeType.Element, "", "WMSLayerName", curNode );
		}

		public SchemaString GetWMSLayerNameValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetWMSLayerName()
		{
			return this.GetWMSLayerNameAt(0);
		}

		public SchemaString WMSLayerName
		{
			get
			{
				return this.GetWMSLayerNameAt(0);
			}
		}

		public void RemoveWMSLayerNameAt(int index)
		{
            this.RemoveDomChildAt(NodeType.Element, "", "WMSLayerName", index);
		}

		public void RemoveWMSLayerName()
		{
			while (this.HasWMSLayerName()) this.RemoveWMSLayerNameAt(0);
		}

		public void AddWMSLayerName(SchemaString newValue)
		{
            this.AppendDomChild(NodeType.Element, "", "WMSLayerName", newValue.ToString());
		}

		public void InsertWMSLayerNameAt(SchemaString newValue, int index)
		{
            this.InsertDomChildAt(NodeType.Element, "", "WMSLayerName", index, newValue.ToString());
		}

		public void ReplaceWMSLayerNameAt(SchemaString newValue, int index)
		{
            this.ReplaceDomChildAt(NodeType.Element, "", "WMSLayerName", index, newValue.ToString());
		}
		#endregion // WMSLayerName accessor methods

		#region WMSLayerName collection
        public WMSLayerNameCollection	MyWMSLayerNames = new WMSLayerNameCollection( );

        public class WMSLayerNameCollection: IEnumerable
        {
            Type_WMSAccessor2 parent;
            public Type_WMSAccessor2 Parent
			{
				set
				{
                    this.parent = value;
				}
			}
			public WMSLayerNameEnumerator GetEnumerator() 
			{
				return new WMSLayerNameEnumerator(this.parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return this.GetEnumerator();
			}
        }

        public class WMSLayerNameEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor2 parent;
			public WMSLayerNameEnumerator(Type_WMSAccessor2 par) 
			{
                this.parent = par;
                this.nIndex = -1;
			}
			public void Reset() 
			{
                this.nIndex = -1;
			}
			public bool MoveNext() 
			{
                this.nIndex++;
				return(this.nIndex < this.parent.WMSLayerNameCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(this.parent.GetWMSLayerNameAt(this.nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(this.Current);
				}
			}
    	}

        #endregion // WMSLayerName collection

		#region WMSLayerStyle accessor methods
		public int GetWMSLayerStyleMinCount()
		{
			return 0;
		}

		public int WMSLayerStyleMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetWMSLayerStyleMaxCount()
		{
			return 1;
		}

		public int WMSLayerStyleMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetWMSLayerStyleCount()
		{
			return this.DomChildCount(NodeType.Element, "", "WMSLayerStyle");
		}

		public int WMSLayerStyleCount
		{
			get
			{
				return this.DomChildCount(NodeType.Element, "", "WMSLayerStyle");
			}
		}

		public bool HasWMSLayerStyle()
		{
			return this.HasDomChild(NodeType.Element, "", "WMSLayerStyle");
		}

		public SchemaString GetWMSLayerStyleAt(int index)
		{
			return new SchemaString(GetDomNodeValue(this.GetDomChildAt(NodeType.Element, "", "WMSLayerStyle", index)));
		}

		public XmlNode GetStartingWMSLayerStyleCursor()
		{
			return this.GetDomFirstChild( NodeType.Element, "", "WMSLayerStyle" );
		}

		public XmlNode GetAdvancedWMSLayerStyleCursor( XmlNode curNode )
		{
			return this.GetDomNextChild( NodeType.Element, "", "WMSLayerStyle", curNode );
		}

		public SchemaString GetWMSLayerStyleValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetWMSLayerStyle()
		{
			return this.GetWMSLayerStyleAt(0);
		}

		public SchemaString WMSLayerStyle
		{
			get
			{
				return this.GetWMSLayerStyleAt(0);
			}
		}

		public void RemoveWMSLayerStyleAt(int index)
		{
            this.RemoveDomChildAt(NodeType.Element, "", "WMSLayerStyle", index);
		}

		public void RemoveWMSLayerStyle()
		{
			while (this.HasWMSLayerStyle()) this.RemoveWMSLayerStyleAt(0);
		}

		public void AddWMSLayerStyle(SchemaString newValue)
		{
            this.AppendDomChild(NodeType.Element, "", "WMSLayerStyle", newValue.ToString());
		}

		public void InsertWMSLayerStyleAt(SchemaString newValue, int index)
		{
            this.InsertDomChildAt(NodeType.Element, "", "WMSLayerStyle", index, newValue.ToString());
		}

		public void ReplaceWMSLayerStyleAt(SchemaString newValue, int index)
		{
            this.ReplaceDomChildAt(NodeType.Element, "", "WMSLayerStyle", index, newValue.ToString());
		}
		#endregion // WMSLayerStyle accessor methods

		#region WMSLayerStyle collection
        public WMSLayerStyleCollection	MyWMSLayerStyles = new WMSLayerStyleCollection( );

        public class WMSLayerStyleCollection: IEnumerable
        {
            Type_WMSAccessor2 parent;
            public Type_WMSAccessor2 Parent
			{
				set
				{
                    this.parent = value;
				}
			}
			public WMSLayerStyleEnumerator GetEnumerator() 
			{
				return new WMSLayerStyleEnumerator(this.parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return this.GetEnumerator();
			}
        }

        public class WMSLayerStyleEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor2 parent;
			public WMSLayerStyleEnumerator(Type_WMSAccessor2 par) 
			{
                this.parent = par;
                this.nIndex = -1;
			}
			public void Reset() 
			{
                this.nIndex = -1;
			}
			public bool MoveNext() 
			{
                this.nIndex++;
				return(this.nIndex < this.parent.WMSLayerStyleCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(this.parent.GetWMSLayerStyleAt(this.nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(this.Current);
				}
			}
    	}

        #endregion // WMSLayerStyle collection

		#region UseTransparency accessor methods
		public int GetUseTransparencyMinCount()
		{
			return 1;
		}

		public int UseTransparencyMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetUseTransparencyMaxCount()
		{
			return 1;
		}

		public int UseTransparencyMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetUseTransparencyCount()
		{
			return this.DomChildCount(NodeType.Element, "", "UseTransparency");
		}

		public int UseTransparencyCount
		{
			get
			{
				return this.DomChildCount(NodeType.Element, "", "UseTransparency");
			}
		}

		public bool HasUseTransparency()
		{
			return this.HasDomChild(NodeType.Element, "", "UseTransparency");
		}

		public SchemaBoolean GetUseTransparencyAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(this.GetDomChildAt(NodeType.Element, "", "UseTransparency", index)));
		}

		public XmlNode GetStartingUseTransparencyCursor()
		{
			return this.GetDomFirstChild( NodeType.Element, "", "UseTransparency" );
		}

		public XmlNode GetAdvancedUseTransparencyCursor( XmlNode curNode )
		{
			return this.GetDomNextChild( NodeType.Element, "", "UseTransparency", curNode );
		}

		public SchemaBoolean GetUseTransparencyValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaBoolean( curNode.InnerText );
		}


		public SchemaBoolean GetUseTransparency()
		{
			return this.GetUseTransparencyAt(0);
		}

		public SchemaBoolean UseTransparency
		{
			get
			{
				return this.GetUseTransparencyAt(0);
			}
		}

		public void RemoveUseTransparencyAt(int index)
		{
            this.RemoveDomChildAt(NodeType.Element, "", "UseTransparency", index);
		}

		public void RemoveUseTransparency()
		{
			while (this.HasUseTransparency()) this.RemoveUseTransparencyAt(0);
		}

		public void AddUseTransparency(SchemaBoolean newValue)
		{
            this.AppendDomChild(NodeType.Element, "", "UseTransparency", newValue.ToString());
		}

		public void InsertUseTransparencyAt(SchemaBoolean newValue, int index)
		{
            this.InsertDomChildAt(NodeType.Element, "", "UseTransparency", index, newValue.ToString());
		}

		public void ReplaceUseTransparencyAt(SchemaBoolean newValue, int index)
		{
            this.ReplaceDomChildAt(NodeType.Element, "", "UseTransparency", index, newValue.ToString());
		}
		#endregion // UseTransparency accessor methods

		#region UseTransparency collection
        public UseTransparencyCollection	MyUseTransparencys = new UseTransparencyCollection( );

        public class UseTransparencyCollection: IEnumerable
        {
            Type_WMSAccessor2 parent;
            public Type_WMSAccessor2 Parent
			{
				set
				{
                    this.parent = value;
				}
			}
			public UseTransparencyEnumerator GetEnumerator() 
			{
				return new UseTransparencyEnumerator(this.parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return this.GetEnumerator();
			}
        }

        public class UseTransparencyEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor2 parent;
			public UseTransparencyEnumerator(Type_WMSAccessor2 par) 
			{
                this.parent = par;
                this.nIndex = -1;
			}
			public void Reset() 
			{
                this.nIndex = -1;
			}
			public bool MoveNext() 
			{
                this.nIndex++;
				return(this.nIndex < this.parent.UseTransparencyCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(this.parent.GetUseTransparencyAt(this.nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(this.Current);
				}
			}
    	}

        #endregion // UseTransparency collection

		#region CacheExpirationTime accessor methods
		public int GetCacheExpirationTimeMinCount()
		{
			return 0;
		}

		public int CacheExpirationTimeMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetCacheExpirationTimeMaxCount()
		{
			return 1;
		}

		public int CacheExpirationTimeMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetCacheExpirationTimeCount()
		{
			return this.DomChildCount(NodeType.Element, "", "CacheExpirationTime");
		}

		public int CacheExpirationTimeCount
		{
			get
			{
				return this.DomChildCount(NodeType.Element, "", "CacheExpirationTime");
			}
		}

		public bool HasCacheExpirationTime()
		{
			return this.HasDomChild(NodeType.Element, "", "CacheExpirationTime");
		}

		public Type_SimpleTimeSpan2 GetCacheExpirationTimeAt(int index)
		{
			return new Type_SimpleTimeSpan2(this.GetDomChildAt(NodeType.Element, "", "CacheExpirationTime", index));
		}

		public XmlNode GetStartingCacheExpirationTimeCursor()
		{
			return this.GetDomFirstChild( NodeType.Element, "", "CacheExpirationTime" );
		}

		public XmlNode GetAdvancedCacheExpirationTimeCursor( XmlNode curNode )
		{
			return this.GetDomNextChild( NodeType.Element, "", "CacheExpirationTime", curNode );
		}

		public Type_SimpleTimeSpan2 GetCacheExpirationTimeValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new Type_SimpleTimeSpan2( curNode );
		}


		public Type_SimpleTimeSpan2 GetCacheExpirationTime()
		{
			return this.GetCacheExpirationTimeAt(0);
		}

		public Type_SimpleTimeSpan2 CacheExpirationTime
		{
			get
			{
				return this.GetCacheExpirationTimeAt(0);
			}
		}

		public void RemoveCacheExpirationTimeAt(int index)
		{
            this.RemoveDomChildAt(NodeType.Element, "", "CacheExpirationTime", index);
		}

		public void RemoveCacheExpirationTime()
		{
			while (this.HasCacheExpirationTime()) this.RemoveCacheExpirationTimeAt(0);
		}

		public void AddCacheExpirationTime(Type_SimpleTimeSpan2 newValue)
		{
            this.AppendDomElement("", "CacheExpirationTime", newValue);
		}

		public void InsertCacheExpirationTimeAt(Type_SimpleTimeSpan2 newValue, int index)
		{
            this.InsertDomElementAt("", "CacheExpirationTime", index, newValue);
		}

		public void ReplaceCacheExpirationTimeAt(Type_SimpleTimeSpan2 newValue, int index)
		{
            this.ReplaceDomElementAt("", "CacheExpirationTime", index, newValue);
		}
		#endregion // CacheExpirationTime accessor methods

		#region CacheExpirationTime collection
        public CacheExpirationTimeCollection	MyCacheExpirationTimes = new CacheExpirationTimeCollection( );

        public class CacheExpirationTimeCollection: IEnumerable
        {
            Type_WMSAccessor2 parent;
            public Type_WMSAccessor2 Parent
			{
				set
				{
                    this.parent = value;
				}
			}
			public CacheExpirationTimeEnumerator GetEnumerator() 
			{
				return new CacheExpirationTimeEnumerator(this.parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return this.GetEnumerator();
			}
        }

        public class CacheExpirationTimeEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor2 parent;
			public CacheExpirationTimeEnumerator(Type_WMSAccessor2 par) 
			{
                this.parent = par;
                this.nIndex = -1;
			}
			public void Reset() 
			{
                this.nIndex = -1;
			}
			public bool MoveNext() 
			{
                this.nIndex++;
				return(this.nIndex < this.parent.CacheExpirationTimeCount );
			}
			public Type_SimpleTimeSpan2  Current 
			{
				get 
				{
					return(this.parent.GetCacheExpirationTimeAt(this.nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(this.Current);
				}
			}
    	}

        #endregion // CacheExpirationTime collection

		#region BoundingBoxOverlap accessor methods
		public int GetBoundingBoxOverlapMinCount()
		{
			return 0;
		}

		public int BoundingBoxOverlapMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetBoundingBoxOverlapMaxCount()
		{
			return 1;
		}

		public int BoundingBoxOverlapMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetBoundingBoxOverlapCount()
		{
			return this.DomChildCount(NodeType.Element, "", "BoundingBoxOverlap");
		}

		public int BoundingBoxOverlapCount
		{
			get
			{
				return this.DomChildCount(NodeType.Element, "", "BoundingBoxOverlap");
			}
		}

		public bool HasBoundingBoxOverlap()
		{
			return this.HasDomChild(NodeType.Element, "", "BoundingBoxOverlap");
		}

		public BoundingBoxOverlapType2 GetBoundingBoxOverlapAt(int index)
		{
			return new BoundingBoxOverlapType2(GetDomNodeValue(this.GetDomChildAt(NodeType.Element, "", "BoundingBoxOverlap", index)));
		}

		public XmlNode GetStartingBoundingBoxOverlapCursor()
		{
			return this.GetDomFirstChild( NodeType.Element, "", "BoundingBoxOverlap" );
		}

		public XmlNode GetAdvancedBoundingBoxOverlapCursor( XmlNode curNode )
		{
			return this.GetDomNextChild( NodeType.Element, "", "BoundingBoxOverlap", curNode );
		}

		public BoundingBoxOverlapType2 GetBoundingBoxOverlapValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new BoundingBoxOverlapType2( curNode.InnerText );
		}


		public BoundingBoxOverlapType2 GetBoundingBoxOverlap()
		{
			return this.GetBoundingBoxOverlapAt(0);
		}

		public BoundingBoxOverlapType2 BoundingBoxOverlap
		{
			get
			{
				return this.GetBoundingBoxOverlapAt(0);
			}
		}

		public void RemoveBoundingBoxOverlapAt(int index)
		{
            this.RemoveDomChildAt(NodeType.Element, "", "BoundingBoxOverlap", index);
		}

		public void RemoveBoundingBoxOverlap()
		{
			while (this.HasBoundingBoxOverlap()) this.RemoveBoundingBoxOverlapAt(0);
		}

		public void AddBoundingBoxOverlap(BoundingBoxOverlapType2 newValue)
		{
            this.AppendDomChild(NodeType.Element, "", "BoundingBoxOverlap", newValue.ToString());
		}

		public void InsertBoundingBoxOverlapAt(BoundingBoxOverlapType2 newValue, int index)
		{
            this.InsertDomChildAt(NodeType.Element, "", "BoundingBoxOverlap", index, newValue.ToString());
		}

		public void ReplaceBoundingBoxOverlapAt(BoundingBoxOverlapType2 newValue, int index)
		{
            this.ReplaceDomChildAt(NodeType.Element, "", "BoundingBoxOverlap", index, newValue.ToString());
		}
		#endregion // BoundingBoxOverlap accessor methods

		#region BoundingBoxOverlap collection
        public BoundingBoxOverlapCollection	MyBoundingBoxOverlaps = new BoundingBoxOverlapCollection( );

        public class BoundingBoxOverlapCollection: IEnumerable
        {
            Type_WMSAccessor2 parent;
            public Type_WMSAccessor2 Parent
			{
				set
				{
                    this.parent = value;
				}
			}
			public BoundingBoxOverlapEnumerator GetEnumerator() 
			{
				return new BoundingBoxOverlapEnumerator(this.parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return this.GetEnumerator();
			}
        }

        public class BoundingBoxOverlapEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor2 parent;
			public BoundingBoxOverlapEnumerator(Type_WMSAccessor2 par) 
			{
                this.parent = par;
                this.nIndex = -1;
			}
			public void Reset() 
			{
                this.nIndex = -1;
			}
			public bool MoveNext() 
			{
                this.nIndex++;
				return(this.nIndex < this.parent.BoundingBoxOverlapCount );
			}
			public BoundingBoxOverlapType2  Current 
			{
				get 
				{
					return(this.parent.GetBoundingBoxOverlapAt(this.nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(this.Current);
				}
			}
    	}

        #endregion // BoundingBoxOverlap collection

		#region ServerLogoFilePath accessor methods
		public int GetServerLogoFilePathMinCount()
		{
			return 0;
		}

		public int ServerLogoFilePathMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetServerLogoFilePathMaxCount()
		{
			return 1;
		}

		public int ServerLogoFilePathMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetServerLogoFilePathCount()
		{
			return this.DomChildCount(NodeType.Element, "", "ServerLogoFilePath");
		}

		public int ServerLogoFilePathCount
		{
			get
			{
				return this.DomChildCount(NodeType.Element, "", "ServerLogoFilePath");
			}
		}

		public bool HasServerLogoFilePath()
		{
			return this.HasDomChild(NodeType.Element, "", "ServerLogoFilePath");
		}

		public SchemaString GetServerLogoFilePathAt(int index)
		{
			return new SchemaString(GetDomNodeValue(this.GetDomChildAt(NodeType.Element, "", "ServerLogoFilePath", index)));
		}

		public XmlNode GetStartingServerLogoFilePathCursor()
		{
			return this.GetDomFirstChild( NodeType.Element, "", "ServerLogoFilePath" );
		}

		public XmlNode GetAdvancedServerLogoFilePathCursor( XmlNode curNode )
		{
			return this.GetDomNextChild( NodeType.Element, "", "ServerLogoFilePath", curNode );
		}

		public SchemaString GetServerLogoFilePathValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetServerLogoFilePath()
		{
			return this.GetServerLogoFilePathAt(0);
		}

		public SchemaString ServerLogoFilePath
		{
			get
			{
				return this.GetServerLogoFilePathAt(0);
			}
		}

		public void RemoveServerLogoFilePathAt(int index)
		{
            this.RemoveDomChildAt(NodeType.Element, "", "ServerLogoFilePath", index);
		}

		public void RemoveServerLogoFilePath()
		{
			while (this.HasServerLogoFilePath()) this.RemoveServerLogoFilePathAt(0);
		}

		public void AddServerLogoFilePath(SchemaString newValue)
		{
            this.AppendDomChild(NodeType.Element, "", "ServerLogoFilePath", newValue.ToString());
		}

		public void InsertServerLogoFilePathAt(SchemaString newValue, int index)
		{
            this.InsertDomChildAt(NodeType.Element, "", "ServerLogoFilePath", index, newValue.ToString());
		}

		public void ReplaceServerLogoFilePathAt(SchemaString newValue, int index)
		{
            this.ReplaceDomChildAt(NodeType.Element, "", "ServerLogoFilePath", index, newValue.ToString());
		}
		#endregion // ServerLogoFilePath accessor methods

		#region ServerLogoFilePath collection
        public ServerLogoFilePathCollection	MyServerLogoFilePaths = new ServerLogoFilePathCollection( );

        public class ServerLogoFilePathCollection: IEnumerable
        {
            Type_WMSAccessor2 parent;
            public Type_WMSAccessor2 Parent
			{
				set
				{
                    this.parent = value;
				}
			}
			public ServerLogoFilePathEnumerator GetEnumerator() 
			{
				return new ServerLogoFilePathEnumerator(this.parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return this.GetEnumerator();
			}
        }

        public class ServerLogoFilePathEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor2 parent;
			public ServerLogoFilePathEnumerator(Type_WMSAccessor2 par) 
			{
                this.parent = par;
                this.nIndex = -1;
			}
			public void Reset() 
			{
                this.nIndex = -1;
			}
			public bool MoveNext() 
			{
                this.nIndex++;
				return(this.nIndex < this.parent.ServerLogoFilePathCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(this.parent.GetServerLogoFilePathAt(this.nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(this.Current);
				}
			}
    	}

        #endregion // ServerLogoFilePath collection

        private void SetCollectionParents()
        {
            this.MyUsernames.Parent = this;
            this.MyPasswords.Parent = this;
            this.MyServerGetMapUrls.Parent = this;
            this.MyVersions.Parent = this;
            this.MyImageFormats.Parent = this;
            this.MyWMSLayerNames.Parent = this;
            this.MyWMSLayerStyles.Parent = this;
            this.MyUseTransparencys.Parent = this;
            this.MyCacheExpirationTimes.Parent = this;
            this.MyBoundingBoxOverlaps.Parent = this;
            this.MyServerLogoFilePaths.Parent = this; 
	}
}
}
